#pragma once

#include <unordered_map>
#include <array>

enum class ScoringLocation 
{
    L1_RIGHT, L1_LEFT, L2_RIGHT, L2_LEFT
};

class ScoringPositionMap 
{
public:
    ScoringPositionMap() 
    {

        _scoring_location_map[6] = {{{14.004776794164812, 2.717958119688195, 120.0},{13.71881520583519, 2.552858119688195, 120.0},{13.64496917302948, 2.741163200445083, 120.0},{13.359007584699858, 2.5760632004450827, 120.0}}};
        _scoring_location_map[7] = {{{14.665197999999998, 4.191, 180},{14.665197999999998, 3.8608000000000002, 180},{14.465198, 3.891, 180},{14.465198, 3.5608, 180}}};
        _scoring_location_map[8] = {{{13.71881520583519, 5.498941880311804, -120.0},{14.004776794164812, 5.333841880311804, -120.0},{13.87862282697052, 5.175736799554917, -120.0},{14.164584415300142, 5.010636799554916, -120.0}}};
        _scoring_location_map[9] = {{{12.113027205835188, 5.333841880311805, -60.000000000000014},{12.39898879416481, 5.498941880311805, -60.000000000000014},{12.47283482697052, 5.310636799554917, -60.000000000000014},{12.758796415300141, 5.475736799554917, -60.000000000000014}}};
        _scoring_location_map[10] = {{{11.452606, 3.8608000000000002, 0.0},{11.452606, 4.191, 0.0},{11.652605999999999, 4.1608, 0.0},{11.652605999999999, 4.491, 0.0}}};
        _scoring_location_map[11] = {{{12.39898879416481, 2.552858119688195, 59.999999999999986},{12.113027205835188, 2.7179581196881952, 59.999999999999986},{12.239181173029479, 2.876063200445083, 59.999999999999986},{11.953219584699857, 3.041163200445083, 59.999999999999986}}};

        _scoring_location_map[17] = {{{3.8295367941648095, 2.552858119688195, -120.00000000000001},{3.5435752058351877, 2.7179581196881952, -120.00000000000001},{3.669729173029478, 2.876063200445083, -120.00000000000001},{3.3837675846998567, 3.041163200445083, -120.00000000000001}}};
        _scoring_location_map[18] = {{{2.8829, 3.8608000000000002, 180.0},{2.8829, 4.191, 180.0},{3.0829, 4.1608, 180.0},{3.0829, 4.491, 180.0}}};
        _scoring_location_map[19] = {{{3.5435752058351886, 5.333841880311805, 119.99999999999999},{3.82953679416481, 5.498941880311805, 119.99999999999999},{3.90338282697052, 5.310636799554917, 119.99999999999999},{4.189344415300142, 5.475736799554917, 119.99999999999999}}};
        _scoring_location_map[20] = {{{5.149109205835189, 5.498941880311804, 59.99999999999999},{5.43507079416481, 5.333841880311804, 59.99999999999999},{5.3089168269705205, 5.175736799554917, 59.99999999999999},{5.594878415300142, 5.010636799554916, 59.99999999999999}}};
        _scoring_location_map[21] = {{{6.095746, 4.191, 0.0},{6.095746, 3.8608000000000002, 0.0},{5.895746, 3.891, 0.0},{5.895746, 3.5608, 0.0}}};
        _scoring_location_map[22] = {{{5.43507079416481, 2.717958119688195, -59.99999999999999},{5.149109205835189, 2.552858119688195, -59.99999999999999},{5.075263173029478, 2.741163200445083, -59.99999999999999},{4.7893015846998575, 2.5760632004450827, -59.99999999999999}}};

    }

    // Location returned in meters and degrees (X, Y, deg)
    std::array<double, 3> getPosition(int tag_id, ScoringLocation loc) const 
    {
        // Check if the tag_id exists in the data map
        auto it = _scoring_location_map.find(tag_id);
        if (it == _scoring_location_map.end()) 
        {
            return INVALID_LOCATION;
        }

        // Return the requested array based on the position enum
        const auto& outerArray = it->second;
        return outerArray[static_cast<int>(loc)];
    }

    bool isValidLocation(std::array<double, 3>& loc)
    {
        return loc[0] > 0.0f && loc[1] > 0.0f;
    }

private:
    std::unordered_map<int, std::array<std::array<double, 3>, 4>> _scoring_location_map;

    const std::array<double, 3> INVALID_LOCATION = {-1.0, -1.0, 0.0};
};
